require "luasql.mysql"mysql = luasql.mysql()conMy, serr = mysql:connect("molinetes","root",'pirulo',"127.0.0.1")if serr then	print(serr)end--conMy, serr = mysql:connect("molinetes","root", "pirulo","127.0.0.1")function buildSelect(cur)	local row = cur:fetch({},"*a")	local str = ""	local sep = ""	local cols = cur:getcolnames()	local rows = {}	while row do		rows[row[cols[1]]] = row[cols[2]]		str = string.format("%s%s%s:%s", str,sep,row[cols[1]], row[cols[2]])		sep = ";"		row = cur:fetch({},"*a")	end	return strendfunction buildSelectHtml(cur)	local row = cur:fetch({},"*a")	local str = "<option value='0'>          </option>"	local sep = ""	local cols = cur:getcolnames()	local rows = {}	while row do		rows[row[cols[1]]] = row[cols[2]]		str = string.format("%s%s<option value='%s'>%s</option>", str,sep,row[cols[1]], row[cols[2]])		sep = ""		row = cur:fetch({},"*a")	end	return strendfunction condicion(o,d)	local op = {}	op.eq = "='%s'"	op.ne = "<>'%s'"	op.bw = " LIKE '%s%%'"	op.bn = " NOT LIKE '%s%%'"	op.ew = " LIKE '%%%s'"	op.en = " NOT LIKE '%%%s'"	op.cn = " LIKE '%%%s%%'"	op.nc = " NOT LIKE '%%%s%%'"	op.nu = " IS NULL "	op.un = " IS NOT NULL "	op["in"] = " IN ('%s') "	op.ni = " NOT IN ('%s') "	return string.format(op[o], d)endfunction setWhere()	local str = ""	if __FORM._search == true then		if __FORM.searchField		and __FORM.searchOper		then			str = string.format(" WHERE %s%s ", __FORM.searchField, condicion(__FORM.searchOper, __FORM.searchString))		end	end	local filters = ""	if __FORM.filters and __FORM.filters ~= "" then		t = json.decode(string.unescape(__FORM.filters))		local sep = ""		for _, r in ipairs(t.rules) do			filters = string.format("%s %s %s%s", filters, sep, r.field, condicion(r.op, r.data))			filters = filters:gsub("^%s*(.-)%s*$", "%1")			sep = t.groupOp		end		if filters ~= "" then			if str ~= "" then				str = str .. " AND " .. filters			else				str = "WHERE "..filters			end		end	end	if fixWhere then		if str ~= "" then			str = str .. " AND "..fixWhere		else			str = " WHERE "..fixWhere		end	end	return strendfunction totalRegs(dbCon, tb)	local sql = string.format("SELECT count(*) as total FROM %s %s", tb, setWhere())	local cur, serr = doSQL(conMy,sql)	if serr then		return nil, serr	else		local total = cur:fetch()		cur:close()		if DEBUG >= 5 then 			debugLog("Total Registros "..total)		end		return tonumber(total)	endendfunction buildResponce(cur, tbid)	local rows = {}	if cur then 		local cols = cur:getcolnames()		local row = cur:fetch({},"*a")		while row do			rows[#rows+1] = {}			rows[#rows][tbid] = row[tbid]			local tmp = {}			for _, rowname in pairs(cols) do				tmp[#tmp+1] = row[rowname] or ""			end			rows[#rows]['cell'] = tmp			row = cur:fetch({},"*a")		end	end	return rowsendfunction getRows(dbCon, tb, tbid, tbsel, start, limit)	local sql = string.format("SELECT %s from %s %s ORDER BY %s %s LIMIT %s, %s", tbsel, tb, setWhere(), __FORM.sidx, __FORM.sord, start, limit)	local cur, serr = doSQL(conMy,sql)	return buildResponce(cur, tbid)endfunction doSQL(dbCon, sql)	myfile = io.open("/tmp/cgi.txt","a")	if DEBUG >= 5 then		debugLog(sql.."\n")	end	rslt, serr = dbCon:execute(sql)	if serr then		if DEBUG >= 2 then			debugLog(serr.."\n")		end	end	return rslt, serrend